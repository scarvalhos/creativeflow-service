{
  "version": 3,
  "sources": ["../../src/utils/resolve-references.ts"],
  "sourcesContent": ["import type { OpenAPI } from '@scalar/openapi-types'\n\nimport { ERRORS } from '@/configuration'\nimport type { AnyObject, ErrorObject, Filesystem, FilesystemEntry, ThrowOnErrorOption } from '@/types/index'\n\nimport { getEntrypoint } from './get-entrypoint'\nimport { getSegmentsFromPath } from './get-segments-from-path'\nimport { isObject } from './is-object'\nimport { makeFilesystem } from './make-filesystem'\n\n// TODO: Add support for all pointer words\n// export const pointerWords = new Set([\n//   '$ref',\n//   '$id',\n//   '$anchor',\n//   '$dynamicRef',\n//   '$dynamicAnchor',\n//   '$schema',\n// ])\n\nexport type ResolveReferencesResult = {\n  valid: boolean\n  errors: ErrorObject[]\n  schema: OpenAPI.Document\n}\n\nexport type ResolveReferencesOptions = ThrowOnErrorOption & {\n  /**\n   * Fired when dereferenced a schema.\n   *\n   * Note that for object schemas, its properties may not be dereferenced when the hook is called.\n   */\n  onDereference?: (data: { schema: AnyObject; ref: string }) => void\n}\n\n/**\n * Takes a specification and resolves all references.\n */\nexport function resolveReferences(\n  // Just a specification, or a set of files.\n  input: AnyObject | Filesystem,\n  // Additional options to control the behaviour\n  options?: ResolveReferencesOptions,\n  // Fallback to the entrypoint\n  file?: FilesystemEntry,\n  // Errors that occurred during the process\n  errors: ErrorObject[] = [],\n): ResolveReferencesResult {\n  // Detach from input\n  const clonedInput = structuredClone(input)\n\n  // Make it a filesystem, even if it's just one file\n  const filesystem = makeFilesystem(clonedInput)\n\n  // Get the main file\n  const entrypoint = getEntrypoint(filesystem)\n\n  const finalInput = file?.specification ?? entrypoint.specification\n\n  // Does it look like an OpenAPI document?\n  if (!isObject(finalInput)) {\n    if (options?.throwOnError) {\n      throw new Error(ERRORS.NO_CONTENT)\n    }\n\n    return {\n      valid: false,\n      errors,\n      schema: finalInput as OpenAPI.Document,\n    }\n  }\n\n  // Recursively resolve all references\n  dereference(finalInput, filesystem, file ?? entrypoint, new WeakSet(), errors, options)\n\n  // Remove duplicates (according to message) from errors\n  errors = errors.filter(\n    (error, index, self) => index === self.findIndex((t) => t.message === error.message && t.code === error.code),\n  )\n\n  // Return the resolved specification\n  return {\n    valid: errors.length === 0,\n    errors,\n    schema: finalInput as OpenAPI.Document,\n  }\n}\n\n/**\n * Resolves the circular reference to an object and deletes the $ref properties (in-place).\n */\nfunction dereference(\n  schema: AnyObject,\n  filesystem: Filesystem,\n  entrypoint: FilesystemEntry,\n  // references to resolved object\n  resolvedSchemas: WeakSet<object>,\n  // error output\n  errors: ErrorObject[],\n\n  options?: ResolveReferencesOptions,\n): void {\n  if (schema === null || resolvedSchemas.has(schema)) {\n    return\n  }\n  resolvedSchemas.add(schema)\n\n  function resolveExternal(externalFile: FilesystemEntry) {\n    dereference(externalFile.specification, filesystem, externalFile, resolvedSchemas, errors, options)\n\n    return externalFile\n  }\n\n  while (schema.$ref !== undefined) {\n    // Find the referenced content\n    const resolved = resolveUri(schema.$ref, options, entrypoint, filesystem, resolveExternal, errors)\n\n    // invalid\n    if (typeof resolved !== 'object' || resolved === null) {\n      break\n    }\n    const dereferencedRef = schema.$ref\n\n    // Get rid of the reference\n    delete schema.$ref\n\n    for (const key of Object.keys(resolved)) {\n      if (schema[key] === undefined) {\n        schema[key] = resolved[key]\n      }\n    }\n\n    if (dereferencedRef) {\n      options?.onDereference?.({ schema, ref: dereferencedRef })\n    }\n  }\n\n  // Iterate over the whole object\n  for (const value of Object.values(schema)) {\n    if (typeof value === 'object' && value !== null) {\n      dereference(value, filesystem, entrypoint, resolvedSchemas, errors, options)\n    }\n  }\n}\n\n/**\n * Resolves a URI to a part of the specification\n *\n * The output is not necessarily dereferenced\n */\nfunction resolveUri(\n  // 'foobar.json#/foo/bar'\n  uri: string,\n  options: ResolveReferencesOptions,\n  // { filename: './foobar.json '}\n  file: FilesystemEntry,\n  // [ { filename: './foobar.json '} ]\n  filesystem: Filesystem,\n\n  // a function to resolve references in external file\n  resolve: (file: FilesystemEntry) => FilesystemEntry,\n\n  errors: ErrorObject[],\n): AnyObject | undefined {\n  // Ignore invalid URIs\n  if (typeof uri !== 'string') {\n    if (options?.throwOnError) {\n      throw new Error(ERRORS.INVALID_REFERENCE.replace('%s', uri))\n    }\n\n    errors.push({\n      code: 'INVALID_REFERENCE',\n      message: ERRORS.INVALID_REFERENCE.replace('%s', uri),\n    })\n\n    return undefined\n  }\n\n  // Understand the URI\n  const [prefix, path] = uri.split('#', 2)\n\n  /** Check whether the file is pointing to itself */\n  const isDifferentFile = prefix !== file.filename\n\n  // External references\n  if (prefix && isDifferentFile) {\n    const externalReference = filesystem.find((entry) => {\n      return entry.filename === prefix\n    })\n\n    if (!externalReference) {\n      if (options?.throwOnError) {\n        throw new Error(ERRORS.EXTERNAL_REFERENCE_NOT_FOUND.replace('%s', prefix))\n      }\n\n      errors.push({\n        code: 'EXTERNAL_REFERENCE_NOT_FOUND',\n        message: ERRORS.EXTERNAL_REFERENCE_NOT_FOUND.replace('%s', prefix),\n      })\n\n      return undefined\n    }\n    // $ref: 'other-file.yaml'\n    if (path === undefined) {\n      return externalReference.specification\n    }\n\n    // $ref: 'other-file.yaml#/foo/bar'\n    // resolve refs first before accessing properties directly\n    return resolveUri(`#${path}`, options, resolve(externalReference), filesystem, resolve, errors)\n  }\n\n  // Pointers\n  const segments = getSegmentsFromPath(path)\n\n  // Try to find the URI\n  try {\n    return segments.reduce((acc, key) => {\n      return acc[key]\n    }, file.specification)\n  } catch (_error) {\n    if (options?.throwOnError) {\n      throw new Error(ERRORS.INVALID_REFERENCE.replace('%s', uri))\n    }\n\n    errors.push({\n      code: 'INVALID_REFERENCE',\n      message: ERRORS.INVALID_REFERENCE.replace('%s', uri),\n    })\n  }\n\n  return undefined\n}\n"],
  "mappings": "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",
  "names": []
}
