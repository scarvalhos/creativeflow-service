{
  "version": 3,
  "sources": ["../../src/bundle/bundle.ts"],
  "sourcesContent": ["import { path } from '@scalar/helpers/node/path'\n\nimport { convertToLocalRef } from '@/helpers/convert-to-local-ref'\nimport { getId, getSchemas } from '@/helpers/get-schemas'\nimport { getValueByPath } from '@/helpers/get-value-by-path'\nimport type { UnknownObject } from '@/types'\n\nimport { escapeJsonPointer } from '../helpers/escape-json-pointer'\nimport { getSegmentsFromPath } from '../helpers/get-segments-from-path'\nimport { isJsonObject } from '../helpers/is-json-object'\nimport { isObject } from '../helpers/is-object'\nimport { isYaml } from '../helpers/is-yaml'\nimport { getHash, uniqueValueGeneratorFactory } from './value-generator'\n\n/**\n * Checks if a string is a remote URL (starts with http:// or https://)\n * @param value - The URL string to check\n * @returns true if the string is a remote URL, false otherwise\n * @example\n * ```ts\n * isRemoteUrl('https://example.com/schema.json') // true\n * isRemoteUrl('http://api.example.com/schemas/user.json') // true\n * isRemoteUrl('#/components/schemas/User') // false\n * isRemoteUrl('./local-schema.json') // false\n * ```\n */\nexport function isRemoteUrl(value: string) {\n  try {\n    const url = new URL(value)\n    return url.protocol === 'http:' || url.protocol === 'https:'\n  } catch {\n    return false\n  }\n}\n\n/**\n * Checks if a string represents a file path by ensuring it's not a remote URL,\n * YAML content, or JSON content.\n *\n * @param value - The string to check\n * @returns true if the string appears to be a file path, false otherwise\n * @example\n * ```ts\n * isFilePath('./schemas/user.json') // true\n * isFilePath('https://example.com/schema.json') // false\n * isFilePath('{\"type\": \"object\"}') // false\n * isFilePath('type: object') // false\n * ```\n */\nexport function isFilePath(value: string) {\n  return !isRemoteUrl(value) && !isYaml(value) && !isJsonObject(value)\n}\n\n/**\n * Checks if a string is a local reference (starts with #)\n * @param value - The reference string to check\n * @returns true if the string is a local reference, false otherwise\n * @example\n * ```ts\n * isLocalRef('#/components/schemas/User') // true\n * isLocalRef('https://example.com/schema.json') // false\n * isLocalRef('./local-schema.json') // false\n * ```\n */\nexport function isLocalRef(value: string): boolean {\n  return value.startsWith('#')\n}\n\nexport type ResolveResult = { ok: true; data: unknown; raw: string } | { ok: false }\n\n/**\n * Resolves a string by finding and executing the appropriate plugin.\n * @param value - The string to resolve (URL, file path, etc)\n * @param plugins - Array of plugins that can handle different types of strings\n * @returns A promise that resolves to either the content or an error result\n * @example\n * // Using a URL plugin\n * await resolveContents('https://example.com/schema.json', [urlPlugin])\n * // Using a file plugin\n * await resolveContents('./schemas/user.json', [filePlugin])\n * // No matching plugin returns { ok: false }\n * await resolveContents('#/components/schemas/User', [urlPlugin, filePlugin])\n */\nfunction resolveContents(value: string, plugins: LoaderPlugin[]): Promise<ResolveResult> {\n  const plugin = plugins.find((p) => p.validate(value))\n\n  if (plugin) {\n    return plugin.exec(value)\n  }\n\n  return Promise.resolve({\n    ok: false,\n  })\n}\n\n/**\n * Sets a value at a specified path in an object, creating intermediate objects/arrays as needed.\n * This function traverses the object structure and creates any missing intermediate objects\n * or arrays based on the path segments. If the next segment is a numeric string, it creates\n * an array instead of an object.\n *\n * \u26A0\uFE0F Warning: Be careful with object keys that look like numbers (e.g. \"123\") as this function\n * will interpret them as array indices and create arrays instead of objects. If you need to\n * use numeric-looking keys, consider prefixing them with a non-numeric character.\n *\n * @param obj - The target object to set the value in\n * @param path - The JSON pointer path where the value should be set\n * @param value - The value to set at the specified path\n * @throws {Error} If attempting to set a value at the root path ('')\n *\n * @example\n * const obj = {}\n * setValueAtPath(obj, '/foo/bar/0', 'value')\n * // Result:\n * // {\n * //   foo: {\n * //     bar: ['value']\n * //   }\n * // }\n *\n * @example\n * const obj = { existing: { path: 'old' } }\n * setValueAtPath(obj, '/existing/path', 'new')\n * // Result:\n * // {\n * //   existing: {\n * //     path: 'new'\n * //   }\n * // }\n *\n * @example\n * // \u26A0\uFE0F Warning: This will create an array instead of an object with key \"123\"\n * setValueAtPath(obj, '/foo/123/bar', 'value')\n * // Result:\n * // {\n * //   foo: [\n * //     undefined,\n * //     undefined,\n * //     undefined,\n * //     { bar: 'value' }\n * //   ]\n * // }\n */\nexport function setValueAtPath(obj: any, path: string, value: any): void {\n  if (path === '') {\n    throw new Error(\"Cannot set value at root ('') pointer\")\n  }\n\n  const parts = getSegmentsFromPath(path)\n\n  let current = obj\n\n  for (let i = 0; i < parts.length; i++) {\n    const key = parts[i]\n    const isLast = i === parts.length - 1\n\n    const nextKey = parts[i + 1]\n    const shouldBeArray = /^\\d+$/.test(nextKey ?? '')\n\n    if (isLast) {\n      current[key] = value\n    } else {\n      if (!(key in current) || typeof current[key] !== 'object') {\n        current[key] = shouldBeArray ? [] : {}\n      }\n      current = current[key]\n    }\n  }\n}\n\n/**\n * Resolves a reference path by combining a base path with a relative path.\n * Handles both remote URLs and local file paths.\n *\n * @param base - The base path (can be a URL or local file path)\n * @param relativePath - The relative path to resolve against the base\n * @returns The resolved absolute path\n * @example\n * // Resolve remote URL\n * resolveReferencePath('https://example.com/api/schema.json', 'user.json')\n * // Returns: 'https://example.com/api/user.json'\n *\n * // Resolve local path\n * resolveReferencePath('/path/to/schema.json', 'user.json')\n * // Returns: '/path/to/user.json'\n */\nfunction resolveReferencePath(base: string, relativePath: string) {\n  if (isRemoteUrl(relativePath)) {\n    return relativePath\n  }\n\n  if (isRemoteUrl(base)) {\n    const url = new URL(base)\n\n    // If the url stars with a / we want it to resolve from the origin so we replace the pathname\n    if (relativePath.startsWith('/')) {\n      url.pathname = relativePath\n      return url.toString()\n    }\n\n    const mergedPath = path.join(path.dirname(url.pathname), relativePath)\n    return new URL(mergedPath, base).toString()\n  }\n\n  return path.join(path.dirname(base), relativePath)\n}\n\n/**\n * Prefixes an internal JSON reference with a given path prefix.\n * Takes a local reference (starting with #) and prepends the provided prefix segments.\n *\n * @param input - The internal reference string to prefix (must start with #)\n * @param prefix - Array of path segments to prepend to the reference\n * @returns The prefixed reference string\n * @throws Error if input is not a local reference\n * @example\n * prefixInternalRef('#/components/schemas/User', ['definitions'])\n * // Returns: '#/definitions/components/schemas/User'\n */\nexport function prefixInternalRef(input: string, prefix: string[]) {\n  if (!isLocalRef(input)) {\n    throw 'Please provide an internal ref'\n  }\n\n  return `#/${prefix.map(escapeJsonPointer).join('/')}${input.substring(1)}`\n}\n\n/**\n * Updates internal references in an object by adding a prefix to their paths.\n * Recursively traverses the input object and modifies any local $ref references\n * by prepending the given prefix to their paths. This is used when embedding external\n * documents to maintain correct reference paths relative to the main document.\n *\n * @param input - The object to update references in\n * @param prefix - Array of path segments to prepend to internal reference paths\n * @returns void\n * @example\n * ```ts\n * const input = {\n *   foo: {\n *     $ref: '#/components/schemas/User'\n *   }\n * }\n * prefixInternalRefRecursive(input, ['definitions'])\n * // Result:\n * // {\n * //   foo: {\n * //     $ref: '#/definitions/components/schemas/User'\n * //   }\n * // }\n * ```\n */\nexport function prefixInternalRefRecursive(input: unknown, prefix: string[]) {\n  if (!isObject(input)) {\n    return\n  }\n\n  Object.values(input).forEach((el) => prefixInternalRefRecursive(el, prefix))\n\n  if (typeof input === 'object' && '$ref' in input && typeof input['$ref'] === 'string') {\n    const ref = input['$ref']\n\n    if (!isLocalRef(ref)) {\n      return\n    }\n\n    input['$ref'] = prefixInternalRef(ref, prefix)\n  }\n}\n\n/**\n * Resolves and copies referenced values from a source document to a target document.\n * This function traverses the document and copies referenced values to the target document,\n * while tracking processed references to avoid duplicates. It only processes references\n * that belong to the same external document.\n *\n * @param targetDocument - The document to copy referenced values to\n * @param sourceDocument - The source document containing the references\n * @param referencePath - The JSON pointer path to the reference\n * @param externalRefsKey - The key used for external references (e.g. 'x-ext')\n * @param documentKey - The key identifying the external document\n * @param bundleLocalRefs - Also bundles the local refs\n * @param processedNodes - Set of already processed nodes to prevent duplicates\n * @example\n * ```ts\n * const source = {\n *   components: {\n *     schemas: {\n *       User: {\n *         $ref: '#/x-ext/users~1schema/definitions/Person'\n *       }\n *     }\n *   }\n * }\n *\n * const target = {}\n * resolveAndCopyReferences(\n *   target,\n *   source,\n *   '/components/schemas/User',\n *   'x-ext',\n *   'users/schema'\n * )\n * // Result: target will contain the User schema with resolved references\n * ```\n */\nexport const resolveAndCopyReferences = (\n  targetDocument: unknown,\n  sourceDocument: unknown,\n  referencePath: string,\n  externalRefsKey: string,\n  documentKey: string,\n  bundleLocalRefs = false,\n  processedNodes = new Set(),\n) => {\n  const referencedValue = getValueByPath(sourceDocument, getSegmentsFromPath(referencePath)).value\n\n  if (processedNodes.has(referencedValue)) {\n    return\n  }\n  processedNodes.add(referencedValue)\n\n  setValueAtPath(targetDocument, referencePath, referencedValue)\n\n  // Do the same for each local ref\n  const traverse = (node: unknown) => {\n    if (!node || typeof node !== 'object') {\n      return\n    }\n\n    if ('$ref' in node && typeof node['$ref'] === 'string') {\n      // We only process references from the same external document because:\n      // 1. Other documents will be handled in separate recursive branches\n      // 2. The source document only contains the current document's content\n      // This prevents undefined behavior and maintains proper document boundaries\n      if (node['$ref'].startsWith(`#/${externalRefsKey}/${escapeJsonPointer(documentKey)}`)) {\n        resolveAndCopyReferences(\n          targetDocument,\n          sourceDocument,\n          node['$ref'].substring(1),\n          externalRefsKey,\n          documentKey,\n          bundleLocalRefs,\n          processedNodes,\n        )\n      }\n      // Bundle the local refs as well\n      else if (bundleLocalRefs) {\n        resolveAndCopyReferences(\n          targetDocument,\n          sourceDocument,\n          node['$ref'].substring(1),\n          externalRefsKey,\n          documentKey,\n          bundleLocalRefs,\n          processedNodes,\n        )\n      }\n    }\n\n    for (const value of Object.values(node)) {\n      traverse(value)\n    }\n  }\n\n  traverse(referencedValue)\n}\n\n/**\n * A loader plugin for resolving external references during bundling.\n * Loader plugins are responsible for handling specific types of external references,\n * such as files, URLs, or custom protocols. Each loader plugin must provide:\n *\n * - A `validate` function to determine if the plugin can handle a given reference string.\n * - An `exec` function to asynchronously fetch and resolve the referenced data,\n *   returning a Promise that resolves to a `ResolveResult`.\n *\n * Loader plugins enable extensible support for different reference sources in the bundler.\n *\n * @property type - The plugin type, always 'loader' for loader plugins.\n * @property validate - Function to check if the plugin can handle a given reference value.\n * @property exec - Function to fetch and resolve the reference, returning the resolved data.\n */\nexport type LoaderPlugin = {\n  type: 'loader'\n  // Returns true if this plugin can handle the given reference value\n  validate: (value: string) => boolean\n  // Asynchronously fetches and resolves the reference, returning the resolved data\n  exec: (value: string) => Promise<ResolveResult>\n}\n\n/**\n * Context information for a node during traversal or processing.\n *\n * Note: The `path` parameter represents the path to the current node being processed.\n * If you are performing a partial bundle (i.e., providing a custom root), this path will be relative\n * to the root you provide, not the absolute root of the original document. You may need to prefix\n * it with your own base path if you want to construct a full path from the absolute document root.\n *\n * - `path`: The JSON pointer path (as an array of strings) from the document root to the current node.\n * - `resolutionCache`: A cache for storing promises of resolved references.\n */\ntype NodeProcessContext = {\n  path: readonly string[]\n  resolutionCache: Map<string, Promise<Readonly<ResolveResult>>>\n  parentNode: UnknownObject | null\n  rootNode: UnknownObject\n  loaders: LoaderPlugin[]\n}\n\n/**\n * A plugin type for lifecycle hooks, allowing custom logic to be injected into the bundler's process.\n * This type extends the Config['hooks'] interface and is identified by type: 'lifecycle'.\n */\nexport type LifecyclePlugin = { type: 'lifecycle' } & Config['hooks']\n\n/**\n * Represents a plugin used by the bundler for extensibility.\n *\n * Plugins can be either:\n * - Loader plugins: Responsible for resolving and loading external references (e.g., from files, URLs, or custom sources).\n * - Lifecycle plugins: Provide lifecycle hooks to customize or extend the bundling process.\n *\n * Loader plugins must implement:\n *   - `validate`: Checks if the plugin can handle a given reference value.\n *   - `exec`: Asynchronously resolves and returns the referenced data.\n *\n * Lifecycle plugins extend the bundler's lifecycle hooks for custom logic.\n */\nexport type Plugin = LoaderPlugin | LifecyclePlugin\n\n/**\n * Configuration options for the bundler.\n * Controls how external references are resolved and processed during bundling.\n */\ntype Config = {\n  /**\n   * Array of plugins that handle resolving references from different sources.\n   * Each plugin is responsible for fetching and processing data from specific sources\n   * like URLs or the filesystem.\n   */\n  plugins: Plugin[]\n\n  /**\n   * Optional root object that serves as the base document when bundling a subpart.\n   * This allows resolving references relative to the root document's location,\n   * ensuring proper path resolution for nested references.\n   */\n  root?: UnknownObject\n\n  /**\n   * Optional maximum depth for reference resolution.\n   * Limits how deeply the bundler will follow and resolve nested $ref pointers.\n   * Useful for preventing infinite recursion or excessive resource usage.\n   */\n  depth?: number\n\n  /**\n   * Optional origin path for the bundler.\n   * Used to resolve relative paths in references, especially when the input is a string URL or file path.\n   * If not provided, the bundler will use the input value as the origin.\n   */\n  origin?: string\n\n  /**\n   * Optional cache to store promises of resolved references.\n   * Helps avoid duplicate fetches/reads of the same resource by storing\n   * the resolution promises for reuse.\n   */\n  cache?: Map<string, Promise<ResolveResult>>\n\n  /**\n   * Cache of visited nodes during partial bundling.\n   * Used to prevent re-bundling the same tree multiple times when doing partial bundling,\n   * improving performance by avoiding redundant processing of already bundled sections.\n   */\n  visitedNodes?: Set<unknown>\n\n  /**\n   * Enable tree shaking to optimize the bundle size.\n   * When enabled, only the parts of external documents that are actually referenced\n   * will be included in the final bundle.\n   */\n  treeShake: boolean\n\n  /**\n   * Optional flag to generate a URL map.\n   * When enabled, tracks the original source URLs of bundled references\n   * in an x-ext-urls section for reference mapping.\n   */\n  urlMap?: boolean\n\n  /**\n   * Optional function to compress input URLs or file paths before bundling.\n   * Returns either a Promise resolving to the compressed string or the compressed string directly.\n   */\n  compress?: (value: string) => Promise<string> | string\n\n  /**\n   * Optional hooks to monitor the bundler's lifecycle.\n   * Allows tracking the progress and status of reference resolution.\n   */\n  hooks?: Partial<{\n    /**\n     * Optional hook called when the bundler starts resolving a $ref.\n     * Useful for tracking or logging the beginning of a reference resolution.\n     */\n    onResolveStart: (node: UnknownObject & Record<'$ref', unknown>) => void\n    /**\n     * Optional hook called when the bundler fails to resolve a $ref.\n     * Can be used for error handling, logging, or custom error reporting.\n     */\n    onResolveError: (node: UnknownObject & Record<'$ref', unknown>) => void\n    /**\n     * Optional hook called when the bundler successfully resolves a $ref.\n     * Useful for tracking successful resolutions or custom post-processing.\n     */\n    onResolveSuccess: (node: UnknownObject & Record<'$ref', unknown>) => void\n    /**\n     * Optional hook invoked before processing a node.\n     * Can be used for preprocessing, mutation, or custom logic before the node is handled by the bundler.\n     */\n    onBeforeNodeProcess: (node: UnknownObject, context: NodeProcessContext) => void | Promise<void>\n    /**\n     * Optional hook invoked after processing a node.\n     * Useful for postprocessing, cleanup, or custom logic after the node has been handled by the bundler.\n     */\n    onAfterNodeProcess: (node: UnknownObject, context: NodeProcessContext) => void | Promise<void>\n  }>\n}\n\n/**\n * Extension keys used for bundling external references in OpenAPI documents.\n * These custom extensions help maintain the structure and traceability of bundled documents.\n */\nconst extensions = {\n  /**\n   * Custom OpenAPI extension key used to store external references.\n   * This key will contain all bundled external documents.\n   * The x-ext key is used to maintain a clean separation between the main\n   * OpenAPI document and its bundled external references.\n   */\n  externalDocuments: 'x-ext',\n\n  /**\n   * Custom OpenAPI extension key used to maintain a mapping between\n   * hashed keys and their original URLs in x-ext.\n   * This mapping is essential for tracking the source of bundled references\n   */\n  externalDocumentsMappings: 'x-ext-urls',\n} as const\n\n/**\n * Bundles an OpenAPI specification by resolving all external references.\n * This function traverses the input object recursively and embeds external $ref\n * references into an x-ext section. External references can be URLs or local files.\n * The original $refs are updated to point to their embedded content in the x-ext section.\n * If the input is an object, it will be modified in place by adding an x-ext\n * property to store resolved external references.\n *\n * @param input - The OpenAPI specification to bundle. Can be either an object or string.\n *                If a string is provided, it will be resolved using the provided plugins.\n *                If no plugin can process the input, the onReferenceError hook will be invoked\n *                and an error will be emitted to the console.\n * @param config - Configuration object containing plugins and options for bundling OpenAPI specifications\n * @returns A promise that resolves to the bundled specification with all references embedded\n * @example\n * // Example with object input\n * const spec = {\n *   paths: {\n *     '/users': {\n *       $ref: 'https://example.com/schemas/users.yaml'\n *     }\n *   }\n * }\n *\n * const bundled = await bundle(spec, {\n *   plugins: [fetchUrls()],\n *   treeShake: true,\n *   urlMap: true,\n *   hooks: {\n *     onResolveStart: (ref) => console.log('Resolving:', ref.$ref),\n *     onResolveSuccess: (ref) => console.log('Resolved:', ref.$ref),\n *     onResolveError: (ref) => console.log('Failed to resolve:', ref.$ref)\n *   }\n * })\n * // Result:\n * // {\n * //   paths: {\n * //     '/users': {\n * //       $ref: '#/x-ext/abc123'\n * //     }\n * //   },\n * //   'x-ext': {\n * //     'abc123': {\n * //       // Resolved content from users.yaml\n * //     }\n * //   },\n * //   'x-ext-urls': {\n * //     'https://example.com/schemas/users.yaml': 'abc123'\n * //   }\n * // }\n *\n * // Example with URL input\n * const bundledFromUrl = await bundle('https://example.com/openapi.yaml', {\n *   plugins: [fetchUrls()],\n *   treeShake: true,\n *   urlMap: true,\n *   hooks: {\n *     onResolveStart: (ref) => console.log('Resolving:', ref.$ref),\n *     onResolveSuccess: (ref) => console.log('Resolved:', ref.$ref),\n *     onResolveError: (ref) => console.log('Failed to resolve:', ref.$ref)\n *   }\n * })\n * // The function will first fetch the OpenAPI spec from the URL,\n * // then bundle all its external references into the x-ext section\n */\nexport async function bundle(input: UnknownObject | string, config: Config) {\n  // Cache for storing promises of resolved external references (URLs and local files)\n  // to avoid duplicate fetches/reads of the same resource\n  const cache = config.cache ?? new Map<string, Promise<ResolveResult>>()\n\n  const loaderPlugins = config.plugins.filter((it) => it.type === 'loader')\n  const lifecyclePlugin = config.plugins.filter((it) => it.type === 'lifecycle')\n\n  /**\n   * Resolves the input value by either returning it directly if it's not a string,\n   * or attempting to resolve it using the provided plugins if it is a string.\n   * @returns The resolved input data or throws an error if resolution fails\n   */\n  const resolveInput = async () => {\n    if (typeof input !== 'string') {\n      return input\n    }\n    const result = await resolveContents(input, loaderPlugins)\n\n    if (result.ok && typeof result.data === 'object') {\n      return result.data\n    }\n\n    throw new Error(\n      'Failed to resolve input: Please provide a valid string value or pass a loader to process the input',\n    )\n  }\n\n  // Resolve the input specification, which could be either a direct object or a string URL/path\n  const rawSpecification = await resolveInput()\n\n  // Document root used to write all external documents\n  // We need this when we want to do a partial bundle of a document\n  const documentRoot = config.root ?? rawSpecification\n\n  // Extract all $id and $anchor values from the document to identify local schemas\n  const schemas = getSchemas(documentRoot)\n\n  // Determines if the bundling operation is partial.\n  // Partial bundling occurs when:\n  // - A root document is provided that is different from the raw specification being bundled, or\n  // - A maximum depth is specified in the config.\n  // In these cases, only a subset of the document may be bundled.\n  const isPartialBundling =\n    (config.root !== undefined && config.root !== rawSpecification) || config.depth !== undefined\n\n  // Set of nodes that have already been processed during bundling to prevent duplicate processing\n  const processedNodes = config.visitedNodes ?? new Set()\n\n  // Determines the initial origin path for the bundler based on the input type.\n  // For string inputs that are URLs or file paths, uses the input as the origin.\n  // For non-string inputs or other string types, returns an empty string.\n  const defaultOrigin = () => {\n    if (config.origin) {\n      return config.origin\n    }\n\n    if (typeof input !== 'string') {\n      return ''\n    }\n\n    if (isRemoteUrl(input) || isFilePath(input)) {\n      return input\n    }\n\n    return ''\n  }\n\n  // Create the cache to store the compressed values to their map values\n  if (documentRoot[extensions.externalDocumentsMappings] === undefined) {\n    documentRoot[extensions.externalDocumentsMappings] = {}\n  }\n  const { generate } = uniqueValueGeneratorFactory(\n    config.compress ?? getHash,\n    documentRoot[extensions.externalDocumentsMappings],\n  )\n\n  const bundler = async (\n    root: unknown,\n    origin: string = defaultOrigin(),\n    isChunkParent = false,\n    depth = 0,\n    currentPath: readonly string[] = [],\n    parent: UnknownObject = null,\n  ) => {\n    // If a maximum depth is set in the config, stop bundling when the current depth reaches or exceeds it\n    if (config.depth !== undefined && depth > config.depth) {\n      return\n    }\n\n    if (!isObject(root) && !Array.isArray(root)) {\n      return\n    }\n\n    // Skip if this node has already been processed to prevent infinite recursion\n    // and duplicate processing of the same node\n    if (processedNodes.has(root)) {\n      return\n    }\n    // Mark this node as processed before continuing\n    processedNodes.add(root)\n\n    // Invoke the onBeforeNodeProcess hook for the current node before any further processing\n    await config.hooks?.onBeforeNodeProcess?.(root as UnknownObject, {\n      path: currentPath,\n      resolutionCache: cache,\n      parentNode: parent,\n      rootNode: documentRoot as UnknownObject,\n      loaders: loaderPlugins,\n    })\n    // Invoke onBeforeNodeProcess hooks from all registered lifecycle plugins\n    for (const plugin of lifecyclePlugin) {\n      await plugin.onBeforeNodeProcess?.(root as UnknownObject, {\n        path: currentPath,\n        resolutionCache: cache,\n        parentNode: parent,\n        rootNode: documentRoot as UnknownObject,\n        loaders: loaderPlugins,\n      })\n    }\n\n    const id = getId(root)\n\n    if (typeof root === 'object' && '$ref' in root && typeof root['$ref'] === 'string') {\n      const ref = root['$ref']\n      const isChunk = '$global' in root && typeof root['$global'] === 'boolean' && root['$global']\n\n      // Try to convert the reference to a local reference if possible\n      // This handles cases where the reference points to a local schema using $id or $anchor\n      // If it can be converted to a local reference, we do not need to bundle it\n      // and can skip further processing for this reference\n      // In case of partial bundling, we still need to ensure that all dependencies\n      // of the local reference are bundled to create a complete and self-contained partial bundle\n      // This is important to maintain the integrity of the partial bundle\n      const localRef = convertToLocalRef(ref, id ?? origin, schemas)\n\n      if (localRef !== undefined) {\n        if (isPartialBundling) {\n          const segments = getSegmentsFromPath(`/${localRef}`)\n          const parent = segments.length > 0 ? getValueByPath(documentRoot, segments.slice(0, -1)).value : undefined\n\n          const targetValue = getValueByPath(documentRoot, segments)\n\n          // When doing partial bundling, we need to recursively bundle all dependencies\n          // referenced by this local reference to ensure the partial bundle is complete.\n          // This includes not just the direct reference but also all its dependencies,\n          // creating a complete and self-contained partial bundle.\n          await bundler(targetValue.value, targetValue.context, isChunkParent, depth + 1, segments, parent)\n        }\n        return\n      }\n\n      const [prefix, path = ''] = ref.split('#', 2)\n\n      // Combine the current origin with the new path to resolve relative references\n      // correctly within the context of the external file being processed\n      const resolvedPath = resolveReferencePath(id ?? origin, prefix)\n\n      // Generate a unique compressed path for the external document\n      // This is used as a key to store and reference the bundled external document\n      // The compression helps reduce the overall file size of the bundled document\n      const compressedPath = await generate(resolvedPath)\n\n      const seen = cache.has(resolvedPath)\n\n      if (!seen) {\n        cache.set(resolvedPath, resolveContents(resolvedPath, loaderPlugins))\n      }\n\n      config?.hooks?.onResolveStart?.(root)\n      lifecyclePlugin.forEach((it) => it.onResolveStart?.(root))\n\n      // Resolve the remote document\n      const result = await cache.get(resolvedPath)\n\n      if (result.ok) {\n        // Process the result only once to avoid duplicate processing and prevent multiple prefixing\n        // of internal references, which would corrupt the reference paths\n        if (!seen) {\n          // Skip prefixing for chunks since they are meant to be self-contained and their\n          // internal references should remain relative to their original location. Chunks\n          // are typically used for modular components that need to maintain their own\n          // reference context without being affected by the main document's structure.\n          if (!isChunk) {\n            // Update internal references in the resolved document to use the correct base path.\n            // When we embed external documents, their internal references need to be updated to\n            // maintain the correct path context relative to the main document. This is crucial\n            // because internal references in the external document are relative to its original\n            // location, but when embedded, they need to be relative to their new location in\n            // the main document's x-ext section. Without this update, internal references\n            // would point to incorrect locations and break the document structure.\n            prefixInternalRefRecursive(result.data, [extensions.externalDocuments, compressedPath])\n          }\n\n          // Recursively process the resolved content\n          // to handle any nested references it may contain. We pass the resolvedPath as the new origin\n          // to ensure any relative references within this content are resolved correctly relative to\n          // their new location in the bundled document.\n          await bundler(result.data, isChunk ? origin : resolvedPath, isChunk, depth + 1, [\n            extensions.externalDocuments,\n            compressedPath,\n            documentRoot[extensions.externalDocumentsMappings],\n          ])\n\n          // Store the mapping between hashed keys and original URLs in x-ext-urls\n          // This allows tracking which external URLs were bundled and their corresponding locations\n          setValueAtPath(\n            documentRoot,\n            `/${extensions.externalDocumentsMappings}/${escapeJsonPointer(compressedPath)}`,\n            resolvedPath,\n          )\n        }\n\n        if (config.treeShake === true) {\n          // Store only the subtree that is actually used\n          // This optimizes the bundle size by only including the parts of the external document\n          // that are referenced, rather than the entire document\n          resolveAndCopyReferences(\n            documentRoot,\n            { [extensions.externalDocuments]: { [compressedPath]: result.data } },\n            prefixInternalRef(`#${path}`, [extensions.externalDocuments, compressedPath]).substring(1),\n            extensions.externalDocuments,\n            compressedPath,\n          )\n        } else if (!seen) {\n          // Store the external document in the main document's x-ext key\n          // When tree shaking is disabled, we include the entire external document\n          // This preserves all content and is faster since we don't need to analyze and copy\n          // specific parts. This approach is ideal when storing the result in memory\n          // as it avoids the overhead of tree shaking operations\n          setValueAtPath(documentRoot, `/${extensions.externalDocuments}/${compressedPath}`, result.data)\n        }\n\n        // Update the $ref to point to the embedded document in x-ext\n        // This is necessary because we need to maintain the correct path context\n        // for the embedded document while preserving its internal structure\n        root.$ref = prefixInternalRef(`#${path}`, [extensions.externalDocuments, compressedPath])\n\n        config?.hooks?.onResolveSuccess?.(root)\n        lifecyclePlugin.forEach((it) => it.onResolveSuccess?.(root))\n\n        return\n      }\n\n      config?.hooks?.onResolveError?.(root)\n      lifecyclePlugin.forEach((it) => it.onResolveError?.(root))\n\n      return console.warn(\n        `Failed to resolve external reference \"${resolvedPath}\". The reference may be invalid, inaccessible, or missing a loader for this type of reference.`,\n      )\n    }\n\n    // Recursively traverse all child properties of the current object to resolve nested $ref references.\n    // This step ensures that any $refs located deeper within the object hierarchy are discovered and processed.\n    // We explicitly skip the extension keys (x-ext and x-ext-urls) to avoid reprocessing already bundled or mapped content.\n    await Promise.all(\n      Object.entries(root).map(async ([key, value]) => {\n        if (key === extensions.externalDocuments || key === extensions.externalDocumentsMappings) {\n          return\n        }\n\n        await bundler(value, id ?? origin, isChunkParent, depth + 1, [...currentPath, key], root as UnknownObject)\n      }),\n    )\n\n    // Invoke the optional onAfterNodeProcess hook from the config, if provided.\n    // This allows for custom post-processing logic after a node has been handled by the bundler.\n    await config.hooks?.onAfterNodeProcess?.(root as UnknownObject, {\n      path: currentPath,\n      resolutionCache: cache,\n      parentNode: parent,\n      rootNode: documentRoot as UnknownObject,\n      loaders: loaderPlugins,\n    })\n\n    // Iterate through all lifecycle plugins and invoke their onAfterNodeProcess hooks, if defined.\n    // This enables plugins to perform additional post-processing or cleanup after the node is processed.\n    for (const plugin of lifecyclePlugin) {\n      await plugin.onAfterNodeProcess?.(root as UnknownObject, {\n        path: currentPath,\n        resolutionCache: cache,\n        parentNode: parent,\n        rootNode: documentRoot as UnknownObject,\n        loaders: loaderPlugins,\n      })\n    }\n  }\n\n  await bundler(rawSpecification)\n\n  // Keep urlMappings when doing partial bundling to track hash values and handle collisions\n  // For full bundling without urlMap config, remove the mappings to clean up the output\n  if (!config.urlMap && !isPartialBundling) {\n    // Remove the external document mappings from the output when doing a full bundle without urlMap config\n    delete documentRoot[extensions.externalDocumentsMappings]\n  }\n\n  return rawSpecification\n}\n"],
  "mappings": "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",
  "names": ["path", "parent"]
}
