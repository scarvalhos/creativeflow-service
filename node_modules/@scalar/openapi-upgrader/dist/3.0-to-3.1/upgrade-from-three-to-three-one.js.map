{
  "version": 3,
  "sources": ["../../src/3.0-to-3.1/upgrade-from-three-to-three-one.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\nimport type { UnknownObject } from '@scalar/types/utils'\n\nimport { traverse } from '@/helpers/traverse'\n\n// Create Sets for faster schema path lookups\nconst SCHEMA_SEGMENTS = new Set([\n  'properties',\n  'items',\n  'allOf',\n  'anyOf',\n  'oneOf',\n  'not',\n  'additionalProperties',\n  'schema',\n])\n\n/** Determine if the current path is within a schema - optimized version */\nexport function isSchemaPath(path: string[] | undefined): boolean {\n  // Early return if path is undefined\n  if (!path) {\n    return false\n  }\n\n  // Check for schema segments first (most common case)\n  if (path.some((segment) => SCHEMA_SEGMENTS.has(segment))) {\n    return true\n  }\n\n  // Check for schema suffix\n  if (path.some((segment) => segment.endsWith('Schema'))) {\n    return true\n  }\n\n  // Check for components/schemas path\n  if (path.length >= 2 && path[0] === 'components' && path[1] === 'schemas') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Upgrade from OpenAPI 3.0.x to 3.1.1\n *\n * https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n */\nexport function upgradeFromThreeToThreeOne(originalContent: UnknownObject) {\n  let content = originalContent\n\n  // Version check - early return if not 3.0.x\n  if (content === null || typeof content.openapi !== 'string' || !content.openapi.startsWith('3.0')) {\n    return content\n  }\n\n  content.openapi = '3.1.1'\n\n  // Single traversal that handles all transformations\n  content = traverse(content, applyChangesToDocument)\n\n  return content as OpenAPIV3_1.Document\n}\n\nconst applyChangesToDocument = (schema: UnknownObject, path?: string[]) => {\n  // 1. Handle nullable types\n  if (schema.type !== undefined && schema.nullable === true) {\n    schema.type = [schema.type, 'null']\n    delete schema.nullable\n  }\n\n  // 2. Handle exclusiveMinimum and exclusiveMaximum\n  if (schema.exclusiveMinimum === true) {\n    schema.exclusiveMinimum = schema.minimum\n    delete schema.minimum\n  } else if (schema.exclusiveMinimum === false) {\n    delete schema.exclusiveMinimum\n  }\n\n  if (schema.exclusiveMaximum === true) {\n    schema.exclusiveMaximum = schema.maximum\n    delete schema.maximum\n  } else if (schema.exclusiveMaximum === false) {\n    delete schema.exclusiveMaximum\n  }\n\n  // 3. Handle examples\n  // Skip conversion if we're already inside an examples map to avoid double nesting\n  // Check if 'examples' appears as an exact path segment (not just a substring)\n  // BUT exclude cases where 'examples' is just a schema property name\n  const isInsideExamplesMap = path?.some((segment, index) => {\n    // Only consider it an examples map if 'examples' is not a schema property name\n    if (segment === 'examples' && index > 0) {\n      const parent = path[index - 1]\n      // If parent is 'properties', then 'examples' is just a property name, not an examples map\n      return parent !== 'properties'\n    }\n    return false\n  })\n\n  if (schema.example !== undefined && !isInsideExamplesMap) {\n    if (isSchemaPath(path)) {\n      schema.examples = [schema.example]\n    } else {\n      schema.examples = {\n        default: {\n          value: schema.example,\n        },\n      }\n    }\n\n    delete schema.example\n  }\n\n  // 4. Handle multipart file uploads\n  if (schema.type === 'object' && schema.properties !== undefined) {\n    const parentPath = path?.slice(0, -1)\n    const isMultipart = parentPath?.some((segment, index) => {\n      return segment === 'content' && path?.[index + 1] === 'multipart/form-data'\n    })\n\n    if (isMultipart && schema.properties !== null) {\n      for (const value of Object.values(schema.properties)) {\n        if (\n          typeof value === 'object' &&\n          value !== null &&\n          'type' in value &&\n          'format' in value &&\n          value.type === 'string' &&\n          value.format === 'binary'\n        ) {\n          value.contentMediaType = 'application/octet-stream'\n\n          delete value.format\n        }\n      }\n    }\n  }\n\n  // 5. Handle binary file uploads\n  if (path?.includes('content') && path?.includes('application/octet-stream')) {\n    return {}\n  }\n\n  // 6. Handle older formats\n  const { format: _, ...rest } = schema\n\n  if (schema.type === 'string') {\n    if (schema.format === 'binary') {\n      return {\n        ...rest,\n        type: 'string',\n        contentMediaType: 'application/octet-stream',\n      }\n    }\n\n    if (schema.format === 'base64') {\n      return {\n        ...rest,\n        type: 'string',\n        contentEncoding: 'base64',\n      }\n    }\n\n    if (schema.format === 'byte') {\n      const parentPath = path?.slice(0, -1)\n      const contentMediaType = parentPath?.find((_, index) => path?.[index - 1] === 'content')\n      return {\n        ...rest,\n        type: 'string',\n        contentEncoding: 'base64',\n        contentMediaType,\n      }\n    }\n  }\n\n  // 7. Handle x-webhooks\n  if (schema['x-webhooks'] !== undefined) {\n    schema.webhooks = schema['x-webhooks']\n    delete schema['x-webhooks']\n  }\n\n  return schema\n}\n"],
  "mappings": "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",
  "names": ["_"]
}
